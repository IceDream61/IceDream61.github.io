<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8">
<title>01背包</title>
<link rel="stylesheet" href="../Resources/GitHub2.css">
<link rel="stylesheet" href="../Resources/prism.css">
</head>

<body>

<h1>01背包</h1>

<pre>
<code class="language-cpp">
/**
&#160;*&#160;&#160;背包问题：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;N件物品，容量为V的背包，第i件物品容量C[i]、价值W[i]
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;求如何填充这个背包能使价值最大
&#160;*&#160;&#160;01背包：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;每件物品只有一个
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;注：01表示每件物品可以放0个或者1个
&#160;*&#160;&#160;算法：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;时间O(NV)，空间O(NV)
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;本次不压缩空间
&#160;*&#160;&#160;变量说明：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;本次采用精确定义d[i][v]，输出方案更舒服：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;定义：只考虑前i件物品，容量恰好用到v时，能达到的最大价值
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;初值：d[0][0]=0,&#160;d[other]=-1（表示无意义）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;更新：d[i][v]&#160;&#60;-&#160;w，表示如果d[i][v]没有值，则直接赋值；如果有，则取最大的
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;推导：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;本次从d[i][v]推过去：&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求i=0~N-1）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i+1][v]&#160;&#60;-&#160;d[i][v]
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i+1][v+C[i+1]]&#160;&#60;-&#160;d[i][v]&#160;+&#160;W[i+1]&#160;&#160;&#160;&#160;（要求v+C[i+1]&#60;=V）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;提及向d[i][v]归过来：&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求i=1~N）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][v]&#160;&#60;-&#160;d[i-1][v]
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][v]&#160;&#60;-&#160;d[i-1][v-C[i]]&#160;+&#160;W[i]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求v-C[i]&#62;=0）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;结果：max(d[N][0~V])
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;顺带介绍模糊定义d[i][v]，不输出方案时的可用于偷懒：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;定义：只考虑前i件物品，容量最多用到v时，能达到的最大价值
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;初值：d[0][0~V]=0,&#160;d[other]=-1（表示无意义）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;更新：d[i][v]&#160;&#60;-&#160;w，表示如果d[i][v]没有值，则直接赋值；如果有，则取最大的
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;推导：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;从d[i][v]推过去：&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求i=0~N-1）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i+1][v]&#160;&#60;-&#160;d[i][v]
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i+1][v]&#160;&#60;-&#160;d[i+1][v-1]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求v-1&#62;=0）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i+1][v+C[i+1]]&#160;&#60;-&#160;d[i][v]&#160;+&#160;W[i+1]&#160;&#160;&#160;&#160;（要求v+C[i+1]&#60;=V）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;向d[i][v]归过来：&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求i=1~N）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][v]&#160;&#60;-&#160;d[i-1][v]
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][v]&#160;&#60;-&#160;d[i][v-1]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求v-1&#62;=0）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][v]&#160;&#60;-&#160;d[i-1][v-C[i]]&#160;+&#160;W[i]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;（要求v-C[i]&#62;=0）
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;结果：d[N][V]
&#160;*&#160;&#160;形象理解：
&#160;*&#160;&#160;&#160;&#160;&#160;&#160;把状态空间画出来就好了
&#160;*/

//&#160;TODO:&#160;初值中后半部分的定义是冗余的

#define&#160;maxn&#160;100
#define&#160;maxv&#160;1000000
#define&#160;UNDEFINED&#160;-1
#include&#160;&#60;stdio.h&#62;

int&#160;max(int&#160;a,&#160;int&#160;b)&#160;{
&#160;&#160;&#160;&#160;return&#160;a&#160;&#62;&#160;b&#160;?&#160;a&#160;:&#160;b;
}

int&#160;N,&#160;V;
int&#160;C[maxn+1],&#160;W[maxn+1];
int&#160;d[maxn+1][maxv+1];

void&#160;Input()&#160;{
&#160;&#160;&#160;&#160;FILE&#160;*in;
&#160;&#160;&#160;&#160;int&#160;i;
&#160;&#160;&#160;&#160;in&#160;=&#160;fopen(&#34;0.in&#34;,&#160;&#34;r&#34;);
&#160;&#160;&#160;&#160;fscanf(in,&#160;&#34;%d%d&#34;,&#160;&#38;N,&#160;&#38;V);
&#160;&#160;&#160;&#160;for(i=1;&#160;i&#60;=N;&#160;++i)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fscanf(in,&#160;&#34;%d%d&#34;,&#160;&#38;C[i],&#160;&#38;W[i]);
&#160;&#160;&#160;&#160;}
}

void&#160;Init()&#160;{
&#160;&#160;&#160;&#160;int&#160;i,&#160;j;
&#160;&#160;&#160;&#160;for(i=0;&#160;i&#60;=N;&#160;++i)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(j=0;&#160;j&#60;=V;&#160;++j)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;d[i][j]&#160;=&#160;UNDEFINED;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;d[0][0]&#160;=&#160;0;
}

void&#160;update(int*&#160;site,&#160;int&#160;w)&#160;{
&#160;&#160;&#160;&#160;if((*site)&#160;==&#160;UNDEFINED)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(*site)&#160;=&#160;w;
&#160;&#160;&#160;&#160;}&#160;else&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(*site)&#160;=&#160;max((*site),&#160;w);
&#160;&#160;&#160;&#160;}
}

void&#160;Work()&#160;{
&#160;&#160;&#160;&#160;int&#160;i,&#160;v;
&#160;&#160;&#160;&#160;for(i=0;&#160;i&#60;=N-1;&#160;++i)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(v=0;&#160;v&#60;=V;&#160;++v)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;update(&#38;d[i+1][v],&#160;d[i][v]);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(v+C[i+1]&#160;&#60;=&#160;V)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;update(&#38;d[i+1][v+C[i+1]],&#160;d[i][v]&#160;+&#160;W[i+1]);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;}
}

void&#160;Output()&#160;{
&#160;&#160;&#160;&#160;int&#160;v;
&#160;&#160;&#160;&#160;int&#160;result&#160;=&#160;0;
&#160;&#160;&#160;&#160;for(v=0;&#160;v&#60;=V;&#160;++v)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;result&#160;=&#160;max(result,&#160;d[N][v]);
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;printf(&#34;%d&#34;,&#160;result);
}

int&#160;main()&#160;{
&#160;&#160;&#160;&#160;Input();
&#160;&#160;&#160;&#160;Init();
&#160;&#160;&#160;&#160;Work();
&#160;&#160;&#160;&#160;Output();
&#160;&#160;&#160;&#160;return&#160;0;
}


</code>
</pre>

<script type="text/javascript" src="../Resources/mathjax.js"></script>
<script type="text/x-mathjax-config">
if (typeof MathJaxListener !== 'undefined') {
  MathJax.Hub.Register.StartupHook('End', function () {
    MathJaxListener.invokeCallbackForKey_('End');
  });
}
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../Resources/prism.js"></script>
</body>

</html>
