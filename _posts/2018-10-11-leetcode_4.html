---
layout: post
title: LeetCode 4 两个排序数组的中位数
excerpt: 
keywords: ""
categories: 
tags: []
---

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> LeetCode 4 两个排序数组的中位数</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 题目分析</h3>
<div class="outline-text-3" id="text-1-1">
<p>
这题数据不咋地。
我这段代码的复杂度其实是O((m+n)/2)，但是直接就通过了，而且时间上战胜的代码数量从13%波动到89%。
可见，LeetCode数据的质量非常低，甚至无法分辨算法的复杂度=。=
</p>

<p>
把twoCondition中主循环改成二分，便可以达到O(log(m)+log(n))。
因为log(m)+log(n)&lt;2log(m+n)，所以这样一来算法的复杂度就是O(log(m+n))。
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Java代码</h3>
<div class="outline-text-3" id="text-1-2">
<div class="org-src-container">

<pre class="src src-java">class Solution {
    double getResult(int[] nums1, int[] nums2, int i, int j) {
	double result = nums1[i];
	if((nums1.length + nums2.length) % 2==0) {
	    int another = 0;
	    boolean hasAnother = false;
	    if(0&lt;=i+1 &amp;&amp; i+1&lt;nums1.length) {
		another = nums1[i+1];
		hasAnother = true;
	    }
	    if(0&lt;=j &amp;&amp; j&lt;nums2.length) {
		if(!hasAnother) {
		    another = nums2[j];
		    hasAnother = true;
		} else if(nums2[j] &lt; another){
		    another = nums2[j];
		}
	    }
	    if(hasAnother) result = (result + another) / 2;
	}
	return result;
    }
    double[] twoCondition(int[] nums1, int[] nums2) {
	int site = (nums1.length + nums2.length - 1) / 2;
	int begin = site - nums2.length, end = site;
	if(begin&lt;0) begin = 0;
	if(end&gt;nums1.length-1) end = nums1.length - 1;
	double[] result = {0, 0};
	for(int i=begin; i&lt;=end; i++) {
	    int j = site - i;
	    if(j&lt;0) j = 0;
	    if(j&gt;nums2.length) j = nums2.length;
	    boolean rightHere = true;
	    if(0&lt;=j-1 &amp;&amp; j-1&lt;nums2.length) rightHere &amp;= nums2[j-1] &lt;= nums1[i];
	    if(0&lt;=j &amp;&amp; j&lt;nums2.length) rightHere &amp;= nums1[i] &lt;= nums2[j];
	    if(rightHere) {
		result[0] = 1;
		result[1] = getResult(nums1, nums2, i, j);
		return result;
	    }
	}
	return result;
    }
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
	double[] result;
	result = twoCondition(nums1, nums2);
	if(result[0] == 1) return result[1];
	result = twoCondition(nums2, nums1);
	if(result[0] == 1) return result[1];
	return 0;
    }
}
</pre>
</div>



<!-- more-forword -->


<!-- more -->
</div>
</div>
</div>
