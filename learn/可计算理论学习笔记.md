# 可计算理论 学习笔记

《可计算理论》是我大三下的课程

这里记录了我对本课内容的理解

## Part 2. 重归课堂

### Church’s Thesis

1. All models define the same set of functions.
2. C is very complicated.3. No one has contrived an intuitively computable function that does not belong to C.(When you are convincing people of the computability of your functions, you are constructing an interpretation from your model to a well-known model.)

### Proof by Church’s Thesis

To prove that f is URM-computable, there are two methods:

Method 1. Write a program that URM-computes f , or prove byindirect means that such a program exists.Method 2. Give an informal proof that the given informal algorithm is indeed an algorithm that serves to compute f .

### Godel Number

> TODO

### The Diagonal Method

### The s-m-n Theorem

### Universal Program

## Part 1. 开学初始

### 疑问

1. URM模型中的一些定理 $\rightarrow$ Substitution定理2：无法理解为什么，ppt中的例子也看不懂，或许理解的关键点在于弄明白 $\simeq$ 符号的含义。

2. Recursion定理的应用实例：$x \dot{-} 1$ 我看不懂如何递归的，这个函数是两段函数，我只能想到在前面再来一个函数作为铺垫的双层递归或许可行。

### 基本概念和记号

可计算函数：可以被计算出来的函数……（说了等于没说）

	可计算函数一定是连续、可数的。
	连续：可用有限的集合表示出来。
	可数：有限；或者虽无限，却可与自然数建立一一映射。

| 符号 | 对应含义 | 备注 |
| :---: | :---: | :---: |
| $C$ | 可计算函数集 | $ C \approx N $ |
| $F$ | 不可计算函数集 | $ F \approx R $ |

### 内容简介

1. URM模型
2. 不可计算
3. Godel不完备定理
4. 规约
5. Complexity

以及我个人可能会补充的内容，例如：lambda演算与URM模型的比较。

### URM模型定义

有存储空间和一段程序，每给出一组输入，便可得到一个输出。

#### 存储空间
无限个寄存器，分别记作 $ r_1, r_2 ... r_n $，每个寄存器可以表示无限大的自然数。

在程序运行开始时，$ r_1 $ 到 $ r_n $ 存的是输入的n个数；

在程序运行结束时，$ r_1 $ 存的是输出的1个数。

注：URM模型中输出只有1个数。

#### 程序
程序就是一个指令序列，记作 $ I_1, I_2 ... I_q $，指令只有以下四种：

| 指令 | 含义（以伪代码描述） |
| :---: | --- |
| $ Z(n) $ | $ r_n \leftarrow 0 $ |
| $ S(n) $ | $ r_n \leftarrow r_n + 1 $ |
| $ T(m,n) $ | $ r_n \leftarrow r_m $ |
| $ J(m,n,q) $ | $ goto \space I_{r_m==r_n \space ? \space q \space : \space next} $ |

程序将在指令全部运行完，或者跳转到不存在的指令时终止。

注：这四条指令中，T指令是可以移除的（等同于语法糖）。

#### 输入输出
对于输入输出的记法如下：

| 记号 | 含义 |
| --- | --- |
| $ P(a_1,a_2,a_3...)$ | 程序输入的初值 |
| $ P(a_1,a_2,a_3...) \downarrow $ | 程序在此输入下，会终止 |
| $ P(a_1,a_2,a_3...) \uparrow $ | 程序在此输入下，不会终止，会发散 |
| $ P(a_1,a_2,a_3...) \downarrow b $ | 程序在此输入下，会终止并输出b |

### URM模型下的可计算函数

可用一段程序对应的函数，具体对应关系如下：

| 函数上一点 | 程序中一对输入输出 |
| --- | --- |
| $ f(a_1,a_2...a_n)=b $ | $ P(a_1,a_2...a_n) \downarrow b $ |
| $ f(a_1,a_2...a_n)=Undefined $ | $ P(a_1,a_2...a_n) \uparrow $ |

这些函数的集合记作 $ C $ ，其中n元函数的集合就记作 $ C_n $ 。

可计算函数，有专门的记法：

| 记号 | 含义 |
| :---: | --- |
| $ f_P^{(n)} $ | 程序P对应的n元函数 |
| $ f_P^{(n)}(x_1,x_2...x_n) $ | 程序P对应的n元函数在点 $ (x_1,x_2...x_n) $ 上的值 |

### URM模型下的可判定谓词

可用一段程序对应的谓词，程序输出不能发散，必须全为0或1。

说详细点，谓词 $ M(x_1,x_2...x_n) $ 对应的判定函数为 $ C_M(x) $ ，其中：

| 函数值 | 谓词判定结果 |
| :---: | :---: |
| 1 | 真 |
| 0 | 假 |

而这个谓词对应的程序，就是其对应的判定函数对应的程序。

### URM模型下的基础可计算函数

| 函数名 | 函数定义 | 对应程序 |
| :--- | :--- | :--- |
| zero | $ f(x)=0 $ | $ I_1: Z(1) $ |
| successor | $ f(x)=x+1 $ | $ I_1: S(1) $ |
| projection | $ U_i^n(x_1,x_2...x_n)=x_i $ | $ I_1: T(i,1) $ |

细心的同学应该发现了，在projection函数中，这个 $i$ 不知是从哪里传过去的。

但我觉得，这是无关紧要的细节，因为想要实现 $i$ 的传递是很容易的。

### URM模型中的程序标准形式

对于程序中任何一条跳转指令，跳转范围只限 $[1,q+1]$ （程序总共q条指令）。

### URM模型中的一些记号

| 记号 | 含义 |
| --- | --- |
| $ \rho(P) $ | 程序P中涉及的所有寄存器中最大的下标 |
| $ P[l_1,...,l_n \rightarrow l] $ | 将 $r_{l_1},...,r_{l_n}$ 作为输入，执行程序P，然后输出至 $r_l$ 处（实现时，去转移、清理相关寄存器即可） |
| $ x \dot{-} y $ | $ (x \geq y) \space ? \space (x-y) \space : \space 0 $ |
| $ sg(x) $ | $ (x==0) \space ? \space 0 \space : \space 1 $ |
| $ \bar{sg}(x) $ | $ (x==0) \space ? \space 1 \space : \space 0 $ |

### URM模型中的一些定理

#### Substitution定理1

若 $f(y_1,...,y_k)$ 可计算，且 $g_1(\vec{x})$ , ... , $g_n(\vec{x})$ 均可计算，其中 $\vec{x}=x_1,...,x_n$，那么 $$h(\vec{x}) \simeq f(g_1(\vec{x}),...,g_k(\vec{x}))$$ 也是可计算函数。

#### Substitution定理2

若 $f(y_1,...,y_k)$ 可计算，且 $x_{i_1},...,x_{i_k}$ 是从 $x_1,...,x_n$ 中取出的（可重复的）k个数，那么 $$h(x_1,...,x_n) \simeq f(x_{i_1},...,x_{i_k})$$ 是可计算函数。

#### Recursion定理

通过递归，由函数 $f(\vec{x})$ 和 $g(\vec{x},y,z)$ 产生的函数这样定义：$$h(\vec{x},0) \simeq f(\vec{x})$$ $$h(\vec{x},y+1) \simeq g(\vec{x},y,h(\vec{x},y))$$

此时，可引出如下定理：

若 $f(\vec{x})$ 和 $g(\vec{x},y,z)$ 是可计算的 ，则 $h(\vec{x},y)$ 也是可计算的。

我对这个定理的理解是：

	所谓递归，其实可以理解成对于一个输入，两段代码的执行。
	第一段代码，负责根据输入生成初始结果，也就是递归第0次的结果；
	第二段代码，则可以由输入和第i次的结果生成新的结果，也就是递归第i+1次的结果。

具体到本定理的描述语言中：

> $h(\vec{x},i)$ 表示以 $\vec{x}$ 作为输入时，递归到第i步的结果；
> 
> $f(\vec{x})$ 表示以 $\vec{x}$ 作为输入时，递归的初值，即第0步的结果；
> 
> $g(\vec{x},y,z)$ 表示以 $\vec{x}$ 作为输入时，由第y步的结果z再推一步，即第y+1步的结果。

#### Recursion定理的应用实例

| h函数 | f函数 | g函数 | 其它表示方法 |
| :--- | :--- | :--- | :--- |
| $ h(x,y)=x+y $ | $ f(x)=x $ | $ g(x,y,z)=z+1 $ |
| $ h(x,y)=xy $ | $ f(x)=0 $ | $ g(x,y,z)=z+x $ |
| $ h(x,y)=x^y $ | $ f(x)=1 $ | $ g(x,y,z)=zx $ |
| $ ? $ | $  $ | $  $ |
| $ h(y)=y \dot{-} 1 $ | $ f=0 $ | $ g(y,z)=y-1 $ |
| $ h(x,y)=x \dot{-} y $ | $ f(x)=x $ | $ g(x,y,z)=z \dot{-} 1 $ |
| $ h(y)=sg(y) $ | $ f=0 $ | $ g=1 $ |
| $ h(y)=\bar{sg}(y) $ | $ f=1 $ | $ g=0 $ | $ \bar{sg}(y) \simeq 1-sg(y) $ |
| $ h(y)=\vert x-y \vert$ | $  $ | $  $ | $ \vert x-y \vert \simeq (x\dot{-}y)+(y\dot{-}x) $ |
| $ h(y)=y! $ | $ f=1 $ | $ g(y,z)=z(y+1) $ |
| $  $ | $  $ | $  $ | $ min(x,y) \simeq x\dot{-}(x\dot{-}y) $ |
| $  $ | $  $ | $  $ | $ max(x,y) \simeq x+(y\dot{-}x) $ |
| $ h(x,y)=rm(x,y) $ | $ f(x)=0 $ | $ g(x,y,z)=(z+1)sg(\vert x-(z+1) \vert) $ |
| $ h(x,y)=qt(x,y) $ | $ f(x)=0 $ | $ g(x,y,z)=z+\bar{sg}(\vert x-(rm(x,y)+1) \vert) $ |
| $  $ | $  $ | $  $ | $ div(x,y)=\bar{sg}(rm(x,y)) $ |

#### 分支结构的可计算性证明

分支结构的定义很简单，一旦 $c_{M_i}$ 条件满足，那么函数值就是 $f_i$ 。

而其可计算性证明，则如下：

$$g(\vec{x}) \simeq c_{M_1}(\vec{x})f_1(\vec{x})+...+c_{M_k}(\vec{x})f_k(\vec{x})$$

#### 逻辑运算中，可判定性的传递

若 $M(\vec{x})$ 和 $Q(\vec{x})$ 均是可判定谓词，则：

1. not $M(\vec{x})$
2. $M(\vec{x})$ and $Q(\vec{x})$
3. $M(\vec{x})$ or $Q(\vec{x})$

亦均是可判定谓词。

#### 求和与求积中，可计算性的传递

Bounded Sum:

$$
\sum_{z<0}f(\vec{x},z) \simeq 0
$$
$$
\sum_{z<y+1}f(\vec{x},z) \simeq \sum_{z<y}f(\vec{x},z) + f(\vec{x},y)
$$

Bounded Product:

$$
\prod_{z<0}f(\vec{x},z) \simeq 0
$$
$$
\prod_{z<y+1}f(\vec{x},z) \simeq (\prod_{z<y}f(\vec{x},z)) \cdot f(\vec{x},y)
$$

Substitution:

$$
\sum_{z<k(\vec{x},\vec{w})}f(\vec{x},z)
$$
$$
\prod_{z<k(\vec{x},\vec{w})}f(\vec{x},z)
$$

### 还有最小和ackman两部分